import type { ScalingApproach } from '@/types/scaling';

export const scalingApproaches: ScalingApproach[] = [
  {
    id: 'hpa',
    name: 'Horizontal Pod Autoscaler',
    shortName: 'HPA',
    shortDescription: 'Adds or removes pod replicas based on CPU, memory, or custom metrics.',
    layer: 'pod',
    direction: 'horizontal',
    bestFor: ['Stateless web apps', 'REST/GraphQL APIs', 'Microservices', 'Frontend services'],
    notRecommendedFor: ['Databases', 'Stateful singletons', 'Batch jobs', 'Workloads needing scale-to-zero'],
    metricsUsed: ['CPU utilization', 'Memory utilization', 'Custom metrics (RPS, latency)', 'External metrics'],
    scalesFromZero: false,
    canCombineWith: ['cluster-autoscaler', 'keda'],
    complexity: 'low',
    implementationSteps: [
      'Install metrics-server in the cluster',
      'Define resource requests on your pod containers',
      'Create an HPA manifest targeting your deployment',
      'Apply and verify with kubectl get hpa --watch',
    ],
    visualizationConfig: {
      initialPods: 2,
      maxPods: 8,
      triggerMetric: 'cpu',
      triggerThreshold: 70,
    },
  },
  {
    id: 'vpa',
    name: 'Vertical Pod Autoscaler',
    shortName: 'VPA',
    shortDescription: 'Automatically adjusts CPU and memory requests for containers based on usage patterns.',
    layer: 'pod',
    direction: 'vertical',
    bestFor: ['Databases (PostgreSQL, MySQL)', 'Monoliths', 'Stateful singletons', 'Right-sizing over-provisioned pods'],
    notRecommendedFor: ['Stateless apps (use HPA)', 'Disruption-intolerant workloads', 'When already using HPA on CPU/memory'],
    metricsUsed: ['CPU usage (P95)', 'Memory usage (peak)', 'OOM events'],
    scalesFromZero: false,
    canCombineWith: ['cluster-autoscaler'],
    complexity: 'medium',
    implementationSteps: [
      'Install VPA components (Recommender, Updater, Admission Controller)',
      'Create a VPA resource in "Off" mode to observe recommendations',
      'Review recommendations after 24-48 hours',
      'Switch to "Auto" mode with minAllowed/maxAllowed bounds',
    ],
    visualizationConfig: {
      initialPods: 1,
      maxPods: 1,
      triggerMetric: 'memory',
      triggerThreshold: 80,
    },
  },
  {
    id: 'cluster-autoscaler',
    name: 'Cluster Autoscaler',
    shortName: 'CA',
    shortDescription: 'Adds or removes nodes in the cluster when pods can\'t be scheduled or nodes are underutilized.',
    layer: 'node',
    direction: 'cluster',
    bestFor: ['Infrastructure elasticity', 'Supporting HPA/KEDA scale-ups', 'Seasonal traffic spikes', 'Cost optimization'],
    notRecommendedFor: ['Bare metal clusters', 'Latency-sensitive workloads (2-5 min provisioning)', 'Fixed-capacity requirements'],
    metricsUsed: ['Pending pods (unschedulable)', 'Node utilization ratio', 'Node unneeded duration'],
    scalesFromZero: false,
    canCombineWith: ['hpa', 'vpa', 'keda'],
    complexity: 'medium',
    implementationSteps: [
      'Configure cloud provider node groups with min/max bounds',
      'Deploy Cluster Autoscaler via Helm or YAML manifest',
      'Configure expander strategy (least-waste recommended)',
      'Set scale-down thresholds and stabilization timers',
    ],
    visualizationConfig: {
      initialPods: 4,
      maxPods: 12,
      triggerMetric: 'pending-pods',
      triggerThreshold: 0,
    },
  },
  {
    id: 'keda',
    name: 'KEDA',
    shortName: 'KEDA',
    shortDescription: 'Event-driven autoscaling based on external sources like queues, streams, and cron schedules. Supports scale-to-zero.',
    layer: 'pod',
    direction: 'event-driven',
    bestFor: ['Queue consumers (RabbitMQ, SQS, Kafka)', 'Event-driven workloads', 'Batch processing', 'Scale-to-zero scenarios'],
    notRecommendedFor: ['Simple CPU-based scaling (use HPA)', 'Cold-start-intolerant apps', 'Environments without CRD support'],
    metricsUsed: ['Queue depth', 'Kafka consumer lag', 'Cron schedule', 'Prometheus queries', '70+ external triggers'],
    scalesFromZero: true,
    canCombineWith: ['cluster-autoscaler'],
    complexity: 'medium',
    implementationSteps: [
      'Install KEDA via Helm',
      'Deploy your consumer workload (can start at 0 replicas)',
      'Create a ScaledObject with trigger configuration',
      'Configure TriggerAuthentication for secure access to event source',
    ],
    visualizationConfig: {
      initialPods: 0,
      maxPods: 8,
      triggerMetric: 'queue-depth',
      triggerThreshold: 5,
    },
  },
];

export function getApproachById(id: string): ScalingApproach | undefined {
  return scalingApproaches.find((a) => a.id === id);
}
