import type { DeploymentStrategy } from '@/types/deployment';

export const deploymentStrategies: DeploymentStrategy[] = [
  {
    id: 'blue-green',
    name: 'Blue-Green Deployment',
    shortName: 'Blue-Green',
    shortDescription: 'Two identical environments with instant traffic switch. Zero-downtime with instant rollback.',
    complexity: 'medium',
    downtime: 'none',
    rollbackSpeed: 'instant',
    bestFor: ['Zero-downtime requirements', 'Financial services', 'Critical APIs', 'Compliance-heavy environments'],
    notRecommendedFor: ['Stateful apps with shared databases', 'Budget-constrained teams (2x infra cost)', 'Frequent small deployments'],
    industries: ['finance', 'transit', 'healthcare'],
    comboWith: ['canary'],
    resourceOverhead: 'high',
    implementationSteps: [
      'Provision identical Blue and Green environments',
      'Deploy new version to inactive (Green) environment',
      'Run smoke tests and health checks against Green',
      'Switch load balancer / DNS to Green',
      'Monitor for errors; rollback by switching back to Blue',
    ],
    realWorldExamples: [
      { company: 'Capital One', useCase: 'Banking API zero-downtime deployments with instant rollback for regulatory compliance' },
      { company: 'Transport for London', useCase: 'Fare calculation engine updates during live transit operations' },
    ],
    visualizationConfig: {
      serversV1: 3,
      serversV2: 3,
      failureTitle: 'Schema migration breaks rollback',
      failureCompany: 'FinanceApp',
      successTitle: 'Clean fare engine switch',
      successCompany: 'Transport for London',
    },
  },
  {
    id: 'canary',
    name: 'Canary Deployment',
    shortName: 'Canary',
    shortDescription: 'Route 1-10% of traffic to the new version, gradually increase if metrics look healthy.',
    complexity: 'high',
    downtime: 'none',
    rollbackSpeed: 'fast',
    bestFor: ['High-traffic production services', 'Services requiring gradual validation', 'Risk-averse teams with monitoring'],
    notRecommendedFor: ['Low-traffic services (insufficient signal)', 'Apps without observability', 'Quick iteration cycles'],
    industries: ['ecommerce', 'saas', 'media'],
    comboWith: ['blue-green', 'shadow'],
    resourceOverhead: 'medium',
    implementationSteps: [
      'Deploy canary version alongside stable production',
      'Route 1-5% of traffic to canary via service mesh or ingress',
      'Monitor error rates, latency, and business metrics',
      'Gradually increase traffic: 5% â†’ 25% â†’ 50% â†’ 100%',
      'Roll back immediately if anomalies detected at any stage',
    ],
    realWorldExamples: [
      { company: 'Facebook', useCase: 'News Feed ranking algorithm changes rolled out to 1% of users over 36 hours' },
      { company: 'Netflix', useCase: 'Recommendation engine updates validated with 2% canary before full rollout' },
    ],
    visualizationConfig: {
      serversV1: 4,
      serversV2: 1,
      failureTitle: 'Missing relevance monitoring',
      failureCompany: 'ShopStream',
      successTitle: '36-hour gradual rollout',
      successCompany: 'Netflix',
    },
  },
  {
    id: 'rolling-update',
    name: 'Rolling Update',
    shortName: 'Rolling',
    shortDescription: 'Replace old pods with new pods one at a time. The Kubernetes default deployment strategy.',
    complexity: 'low',
    downtime: 'none',
    rollbackSpeed: 'fast',
    bestFor: ['Stateless microservices', 'CI/CD pipelines', 'Internal tools', 'Kubernetes-native apps'],
    notRecommendedFor: ['Apps that cannot run mixed versions', 'Schema-breaking database changes', 'Real-time systems needing atomic switch'],
    industries: ['ecommerce', 'saas'],
    comboWith: ['shadow'],
    resourceOverhead: 'low',
    implementationSteps: [
      'Set strategy.type: RollingUpdate in Deployment spec',
      'Configure maxSurge and maxUnavailable',
      'Set readiness probes for health verification',
      'Apply the new Deployment version with kubectl apply',
      'Monitor rollout with kubectl rollout status',
    ],
    realWorldExamples: [
      { company: 'Walmart', useCase: 'Product catalog API updated across 200 pods with zero downtime during business hours' },
      { company: 'Target', useCase: 'Price update service rolled out with maxSurge=1 to maintain consistent pricing' },
    ],
    visualizationConfig: {
      serversV1: 4,
      serversV2: 0,
      failureTitle: 'API incompatibility in mixed state',
      failureCompany: 'RetailAPI',
      successTitle: 'Zero-error price update rollout',
      successCompany: 'Target',
    },
  },
  {
    id: 'recreate',
    name: 'Recreate Deployment',
    shortName: 'Recreate',
    shortDescription: 'Kill all old pods, then start all new pods. Simple but causes brief downtime.',
    complexity: 'low',
    downtime: 'brief',
    rollbackSpeed: 'slow',
    bestFor: ['GPU workloads', 'Legacy monoliths', 'Schema migrations', 'Workloads that cannot run mixed versions'],
    notRecommendedFor: ['Customer-facing services', 'High-availability requirements', 'Frequent deployments'],
    industries: ['iot', 'gaming'],
    comboWith: ['blue-green'],
    resourceOverhead: 'low',
    implementationSteps: [
      'Set strategy.type: Recreate in Deployment spec',
      'Schedule deployment during maintenance window',
      'All old pods are terminated simultaneously',
      'New pods are created and go through readiness checks',
      'Service resumes when new pods are ready',
    ],
    realWorldExamples: [
      { company: 'Siemens', useCase: 'IoT edge gateways updated during scheduled maintenance with exclusive hardware access' },
      { company: 'Riot Games', useCase: 'Match history service deployed during off-peak with 60-second planned downtime' },
    ],
    visualizationConfig: {
      serversV1: 3,
      serversV2: 0,
      failureTitle: 'CrashLoopBackOff during maintenance',
      failureCompany: 'EdgePlatform',
      successTitle: 'Clean 60s planned downtime',
      successCompany: 'Riot Games',
    },
  },
  {
    id: 'ab-testing',
    name: 'A/B Testing Deployment',
    shortName: 'A/B Testing',
    shortDescription: 'Route specific user segments to different versions to measure business impact.',
    complexity: 'high',
    downtime: 'none',
    rollbackSpeed: 'fast',
    bestFor: ['Measuring business metrics', 'UI/UX experiments', 'Pricing optimization', 'Feature validation'],
    notRecommendedFor: ['Infrastructure changes', 'Backend-only changes with no user impact', 'Teams without analytics platform'],
    industries: ['ecommerce', 'media', 'saas'],
    comboWith: ['canary'],
    resourceOverhead: 'medium',
    implementationSteps: [
      'Define user segments and routing rules (header, cookie, geo)',
      'Deploy both versions with distinct version labels',
      'Configure ingress/service mesh to route by segment',
      'Instrument both versions with analytics tracking',
      'Analyze results after statistically significant sample size',
    ],
    realWorldExamples: [
      { company: 'Amazon', useCase: 'Checkout button placement tested across 50M users, 3.2% conversion lift identified' },
      { company: 'Uber', useCase: 'Surge pricing display format A/B tested resulting in 18% acceptance improvement' },
    ],
    visualizationConfig: {
      serversV1: 2,
      serversV2: 2,
      failureTitle: 'Unmonitored bounce rate increase',
      failureCompany: 'ShopFront',
      successTitle: '18% metric improvement found',
      successCompany: 'Uber',
    },
  },
  {
    id: 'shadow',
    name: 'Shadow (Dark) Deployment',
    shortName: 'Shadow',
    shortDescription: 'Mirror production traffic to the new version. Responses are discarded. Zero risk to users.',
    complexity: 'high',
    downtime: 'none',
    rollbackSpeed: 'instant',
    bestFor: ['ML model validation', 'Search algorithm changes', 'High-risk financial calculations', 'Performance benchmarking'],
    notRecommendedFor: ['Write-heavy operations (risk of duplication)', 'Services with external side effects', 'Budget-constrained teams'],
    industries: ['finance', 'search', 'ml'],
    comboWith: ['canary'],
    resourceOverhead: 'high',
    implementationSteps: [
      'Deploy shadow version alongside production',
      'Configure traffic mirroring at the service mesh / proxy layer',
      'Ensure shadow cannot write to production databases or external APIs',
      'Compare shadow responses with production responses (diff analysis)',
      'Promote shadow to canary or production when validated',
    ],
    realWorldExamples: [
      { company: 'Google', useCase: 'Search ranking algorithm changes validated by comparing shadow results against production for 2 weeks' },
      { company: 'Delta Airlines', useCase: 'Dynamic pricing model shadow-tested for 3 weeks before going live' },
    ],
    visualizationConfig: {
      serversV1: 3,
      serversV2: 3,
      failureTitle: 'Shadow contaminates shared Redis',
      failureCompany: 'PriceEngine',
      successTitle: '3-week zero-risk validation',
      successCompany: 'Delta Airlines',
    },
  },
];

export const comboApproaches = [
  {
    id: 'canary-blue-green',
    name: 'Canary + Blue-Green',
    strategies: ['canary', 'blue-green'],
    description: 'Gradual canary validation with instant Blue-Green rollback capability.',
    bestFor: 'Banks and financial services requiring both validation and instant rollback.',
  },
  {
    id: 'shadow-canary',
    name: 'Shadow + Canary',
    strategies: ['shadow', 'canary'],
    description: 'Zero-risk shadow pre-validation, then small canary for real traffic testing.',
    bestFor: 'ML models and search algorithms where shadow validates correctness first.',
  },
  {
    id: 'ab-canary',
    name: 'A/B Testing + Canary',
    strategies: ['ab-testing', 'canary'],
    description: 'Technical canary validation first, then A/B testing for business metrics.',
    bestFor: 'E-commerce platforms measuring conversion alongside reliability.',
  },
  {
    id: 'rolling-shadow',
    name: 'Rolling + Shadow',
    strategies: ['rolling-update', 'shadow'],
    description: 'Shadow pre-validates, then standard rolling rollout.',
    bestFor: 'CDN and API services that need pre-validation before standard rollout.',
  },
  {
    id: 'blue-green-recreate',
    name: 'Blue-Green + Recreate',
    strategies: ['blue-green', 'recreate'],
    description: 'Zero-downtime externally via Blue-Green, simple Recreate internally per environment.',
    bestFor: 'Legacy monoliths that cannot run mixed versions but need zero external downtime.',
  },
];

export function getStrategyById(id: string): DeploymentStrategy | undefined {
  return deploymentStrategies.find((s) => s.id === id);
}
